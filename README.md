# 1. 자료구조
## 1.1. 구간 합 : O(1)
- 문제 : doit_05
## 1.2. 투 포인터 : O(nlogn)
- 문제 : doit_06 ~ doit_08
## 1.3. 슬라이딩 윈도우 : O(n)
- 윈도우를 한 칸씩 이동하며 현재 상태 리스트 업데이트
  - 제거된 칸과 새로 추가된 칸만 반영해서 확인하고 업데이트
  - 윈도우 전체를 스캔할 필요 없이 앞 뒤만 확인하면 되기 때문에 효율적
- 슬라이딩 윈도우를 덱으로 구현하면 정렬 효과
  - 덱(deque) : 양방향 큐로 양쪽 방향에서 엘리먼트를 append 하거나 pop 가능
  - 일반적인 리스트는 양끝 엘리먼트에 접근하여 append, pop하는 경우 O(n) 소요
  - 데크의 경우 양끝 엘리먼트에 접근하여 append, pop하는 경우 O(1) 소요
  - `deque.append(item)`, `deque.appendleft(item)`, `deque.pop()`, `deque.popleft()`
- 문제 : doit_09 ~ doit_10
## 1.4. 스택과 큐
- 스택(stack) : 삽입과 삭제 연산이 후입선출로 이루어지는 자료구조
  - 삽입과 삭제가 한 쪽(top)에서만 일어남
  - 파이썬에서는 list로 구현
  - `s.append(data)`, `s.pop()`, `s[-1]`
  - 깊이 우선 탐색(Depth First Search), 백트래킹 종류의 코딩에 효과적
- 큐(queue) : 삽입과 삭제 연산이 선입선출로 이루어지는 자료구조
  - 삽입(rear)과 삭제(front)가 양방향으로 일어남
  - 파이썬에서는 deque로 구현
  - `q.append(data)`, `q.popleft()`, `q[0]`
  - 너비 우선 탐색(Breadth First Search)에서 자주 사용
- 우선순위 큐(priority queue) : 값이 들어간 순서와 상관없이 우선순위가 높은 데이터가 먼저 나오는 자료구조, 
  - 일반적으로 heap 으로 구현
    - collections.queue.PriorityQueue 내부적으로 heap 모듈 사용
  - 기본적으로 정렬 기준은 오름차순 정렬
    - 정렬 기준 직접 정의해서 적용 가능 (오름차순 정렬보다 우선 적용)
  - `q.put((우선순위, data))`, `q.get()`, `q.empty()`, `q.full()` `q.qsize()`
- 문제 : doit_11 ~ doit_14
# 2. 탐색
## 2.1. 이진 탐색 (Binary Search) : O(logN)
- **데이터가 정렬되어 있는 상태**에서 원하는 값을 찾아내는 알고리즘
- 중앙값 비교를 통한 탐색 범위 절반씩 축소
- 탐색 과정
  - 현재 데이터셋의 중앙값(median) 선택
  - 중앙값 > 타깃 데이터 : 중앙값 기준으로 왼쪽 데이터셋 선택
  - 중앙값 < 타깃 데이터 : 중앙값 기준으로 오른쪽 데이터셋 선택
  - 반복하다가 중앙값 == 타깃 데이터일 때 탐색 종료
- 문제 : doit_29 ~ doit_31
# 3. 그리디
## 3.1. 그리디 알고리즘 수행과정
  - 1단계 : 해 선택
    - 현재 상태에서 가장 최선이라고 생각되는 해를 선택
  - 2단계 : 적절성 검사
    - 현재 선택한 해가 전체 문제의 제약 조건에 벗어나지 않는지 검사
  - 3단계 : 해 검사
    - 현재까지 선택한 해 집합이 전체 문제를 해결할 수 있는지 검사
    - 전체 문제를 해결하지 못한다면 1단계로 돌아가 과정 반복
