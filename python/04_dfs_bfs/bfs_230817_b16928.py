# 뱀과 사다리 게임 (g5, 33.364%)
# source : https://www.acmicpc.net/problem/16928
# keyword : 
# return : 100번 칸에 도착하기 위 주사위를 굴러야 하는 횟수의 최솟값 출력
# 시간 : 14:23 ~ 17:00
"""
1. 문제
- 10*10 보드판에서 주사위 수에 따라 이동
- 1번에서 100번 칸까지 이동
- 사다리 : 위로 올라간다(앞으로 나아간다)
- 뱀 : 아래로 내려간다(돌아간다)

2. 입력
- 사다리의 수 N (1<=N<=15)
- 뱀의 수 M (1<=M<=15)
- 사다리 정보 x, y (x < y)
- 뱀의 정보 u, v (u > v)
- 1번과 100번 칸은 뱀/사다리가 없음
- 모든 칸은 최대 하나의 사다리/뱀을 가짐(2개는 불가)

3. 로직 수정 전
- 각 사다리 칸 별로 최소 경로를 구한다
- dp[i]
    - 뱀 시작점 O : dp[i] = 9999
    - 사다리 종착점 O : dp[시작점]
    - 사다리 종착점 X : min(dp[i-6]~dp[i]) + 1

4. 로직 약점
- 사다리 타고 내려가서 뱀을 타고 올라갔을 때 더 이득인 경우가 존재
- dp는 위의 경우를 업데이트하지 않기 때문에 bfs 권장

4. 로직 수정 후
- bfs + 우선순위큐
- 사다리나 뱀을 만나면 바로 해당 칸으로 이동해서 탐색
"""


import sys
from heapq import heappop, heappush

# 사다리나 뱀으로 연결된 칸 저장
now = [*range(101)]
for conn in [*open(0)][1:]:
    s, e = map(int, conn.split())
    now[s] = e

# 최소 거리 저장
visited = [sys.maxsize for _ in range(101)]
# (거리, 시작점)
pq = [(0, 1)]

while pq:
    dist, cur = heappop(pq)
    for i in range(1, 7):
        # 사다리나 뱀을 만나면 바로 해당 칸으로 이동
        new = now[cur] + i
        if new > 99:
            exit(print(dist+1))
        # 새로운 거리가 기존 거리보다 작으면 pq에 넣기
        elif visited[new] > dist+1:
            visited[new] = dist+1
            heappush(pq, (dist+1, new))


"""
테스트케이스 : 3 / 5 / 4 / 4

3 7
32 62
42 68
12 98
95 13
97 25
93 37
79 27
75 19
49 47
67 17

4 9
8 52
6 80
26 42
2 72
51 19
39 11
37 29
81 3
59 5
79 23
53 7
43 33
77 21

1 5
2 92
94 3
95 4
96 5
97 6
98 7

2 1
5 80
31 99
81 30
"""