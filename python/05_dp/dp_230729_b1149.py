# RGB거리
# source : https://www.acmicpc.net/problem/1149
# keyword : 다이나믹 프로그래밍
# return : 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값 출력

"""
1. 문제
- 1번 집의 색은 2번 집의 색과 다름
- N번 집의 색은 N-1번 집의 색과 다름
- i번 집의 색은 i-1, i+1번 집의 색과 다름

2. 입력
- 집의 수 N (2<=N<=1,000)
- 각 집마다 빨강, 초록, 파랑으로 칠하는 비용

3. 로직
- Bottom-Up, 2차원 배열 활용
- dp[i][0]
    - 집을 i번째까지 칠했을 때 총비용, i번째 집이 빨간색
    - i-1번째 집을 초록/파란색으로 칠했을 때 최소 비용 + i번째 집을 빨강으로 칠할 때 비용
(1) 점화식
    - dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + cost[i][0]
(2) 초깃값
    - dp[1][0] = cost[1][0]
    - dp[1][1] = cost[1][1]
    - dp[1][2] = cost[1][2]
(3) 최종값
    - 총 비용 = min(dp[N][0], dp[N][1], dp[N][2])
"""


N, *ls = map(int, open(0).read().split())
# rgb 비용 담기
#(cost:=[[0,0,0]]).extend([ls[3*i:3*i+3] for i in range(0, N)])
cost = [[0,0,0], *[ls[3*i:3*i+3] for i in range(0, N)]]


# (1) 점화식 구현 - 초깃값 별도 설정 필요X
for i in range(2, N+1):
    cost[i][0] = min(cost[i-1][1], cost[i-1][2]) + cost[i][0]
    cost[i][1] = min(cost[i-1][0], cost[i-1][2]) + cost[i][1]
    cost[i][2] = min(cost[i-1][0], cost[i-1][1]) + cost[i][2]

# (3) 최종값 출력
print(min(cost[N]))


"""
테스트 케이스 : 96 / 3 / 102 / 208 / 253

3
26 40 83
49 60 57
13 89 99

3
1 100 100
100 1 100
100 100 1

3
1 100 100
100 100 100
1 100 100

6
30 19 5
64 77 64
15 19 97
4 71 57
90 86 84
93 32 91

8
71 39 44
32 83 55
51 37 63
89 29 100
83 58 11
65 13 15
47 25 29
60 66 19
"""