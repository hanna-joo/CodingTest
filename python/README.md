# 1. 파이썬 기초

# 2. 자료구조
## (1) 구간 합 : O(1)
## (2) 투 포인터 : O(nlogn)
## (3) 슬라이딩 윈도우 : O(n)
- 윈도우를 한 칸씩 이동하며 현재 상태 리스트 업데이트
- 슬라이딩 윈도우를 덱으로 구현하면 정렬 효과
  - `deque.append(item)`, `deque.appendleft(item)`, `deque.pop()`, `deque.popleft()`
## (4) 스택과 큐
- 스택(stack)
  - 깊이 우선 탐색(Depth First Search), 백트래킹 종류의 코딩에 효과적
- 큐(queue) 
  - 너비 우선 탐색(Breadth First Search)에서 자주 사용
- 우선순위 큐(priority queue)
  - 기본적으로 정렬 기준은 오름차순 정렬
## (5) 해시

# 3. 완전 탐색

# 4. DFS & BFS
## (1) 깊이 우선 탐색 (Depth-First Search)
- 그래프 완전 탐색 기법 중 하나
- 루트 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식
- 방문하고 스택에 넣어놓고 나중에 넣은 것부터 처리(방문하자마자 처리)
- 후입선출, **스택** 또는 **재귀함수**로 구현
- 구현 요소 : 인접리스트, 방문리스트, 스택/재귀 함수(, 시작 노드)
- 작동 과정
  - (a) 시작 노드 입력 
  - (b-1) 시작 노드 방문 기록 있다면 dfs 종료
  - (b-2) 시작 노드 방문 기록 없다면 방문 기록 후 처리
  - (c) 해당 노드의 인접 노드 하나씩 dfs 수행
## (2) 너비 우선 탐색 (Breadth-First Search)
- 루트 노드에서 시작해서 시작 정점으로부터 인접한 노드를 먼저 탐색하는 방식
- 선입선출, **큐**로 구현
- 방문하고 큐에 넣어놓고 가장 먼저 넣은 것부터 처리
- 구현 요소 : 인접리스트, 방문리스트, 큐(, 탐색 방향, 시작 노드)
- 작동 과정
  - (a) 시작 노드 입력
  - (b) 시작 노드 방문 기록 후 큐에 넣기
  - (c) 큐가 빌 때까지 반복
    - (c-1) 큐에서 가장 앞 노드 추출
    - (c-2) 해당 노드 처리
    - (c-3) 해당 노드의 인접 노드 하나씩 방문 및 큐에 삽입
## (3) DFS vs BFS
- 모든 노드를 방문해야 할 때 DFS, BFS
- 각각의 경로마다 특징을 저장해야 할 때 DFS
- 두 노드 사이의 최단 거리 구해야 할 때 BFS
- 시간 복잡도 = 다음 노드가 방문했는지 시간 + 각 노드 방문 시간
- DFS가 BFS에 비해 구현은 쉽지만 검색 속도는 느림

# 5. 다이나믹 프로그래밍
- 중복된 계산 값을 저장해서 중복 연산을 최소화
## (1) 일반
- 해결 방법
  - (a) 중복되는 계산을 찾고 어떤 값을 저장할 지 정한다
  - (b) 점화식을 세운다
  - (c) 초깃값을 지정한다
## (2) 다익스트라
- 다이나믹 프로그래밍을 활용한 최단 경로 탐색 알고리즘
  - 인공위성 GPS 소프트웨어 등에서 많이 사용
- 하나의 정점에서 **다른 모든 정점으로** 가는 최단 경로(음의 간선X)
- B가 A,C와 연결되어 있을 때
  - (a) B까지의 거리 = A까지의 최단 거리 + A와 B의 최단 거리
  - (b) B까지의 거리 = C까지의 최단 거리 + C와 B의 최단 거리
  - B까지의 최단 거리 = min(a, b)
- 현재까지 알고 있던 최단 경로를 계속 갱신
- 작동 과정
  - (a) 출발 노드 방문 (출발 노드의 거리를 무조건 0으로 하지 말자!)
  - (b) 출발 노드 기준으로 각 노드의 최소 비용 저장
  - (c) **방문하지 않은 노드에서 가장 비용이 적은 노드 방문**
  - (d) 해당 노드 거쳐서 특정 노드로 가는 경우 고려해서 최소 비용 갱신
  - (e) (c)-(d)번 과정 반복

# 6. 그리디 알고리즘
- 해결 방법
  - (a) 해 선택 : 현재 상태에서 가장 최선이라고 생각되는 해를 선택
  - (b) 적절성 검사 : 현재 선택한 해가 전체 문제의 제약 조건에 벗어나지 않는지 검사
  - (c) 해 검사
    - 현재까지 선택한 해 집합이 전체 문제를 해결할 수 있는지 검사
    - 전체 문제를 해결하지 못한다면 1단계로 돌아가 과정 반복
## (2) 대표 예시
- 회의실 예약

# 7. 심화 알고리즘
## (1) 이진 탐색 (Binary Search) : O(logN)
- **데이터가 정렬되어 있는 상태**에서 원하는 값을 찾아내는 알고리즘
- 중앙값 비교를 통한 탐색 범위 절반씩 축소
- 작동 과정
  - (a) 현재 데이터셋의 중앙값(median) 선택
  - (b-1) 중앙값 > 타깃 데이터 : 중앙값 기준으로 왼쪽 데이터셋 선택
  - (b-2) 중앙값 < 타깃 데이터 : 중앙값 기준으로 오른쪽 데이터셋 선택
  - (c) 반복하다가 중앙값 == 타깃 데이터일 때 탐색 종료
- 문제 : doit_29 ~ doit_31

# 8. 기타
## 8.1. 시간 복잡도
- O(1) < O(log(n)) < O(nlog(n)) < O(n^2)
- 자료형에 따른 시간 복잡도
  - List : 삽입, 제거, 탐색, 포함 여부 모두 O(n)
    - 단, append, pop, 인덱스 접근은 O(1)
    - 그 외의 탐색, 확인에는 set, dict 권장
  - Set : 삽입, 제거, 탐색, 포함 여부 O(1)
  - Dict : 삽입, 제거, 탐색, 포함 여부 O(1)
- Python은 1초당 2000만번의 연산 가능
- N에 따른 빅오
  - 500 -> O(N^3)
  - 2,000 -> O(N^2)
  - 100,000 -> O(NlogN)
  - 10,000,000 -> O(N)

## 8.2. 입력
- open(0).read().split()
  - 한 번에 모든 입력 받기
  - 입력 종료 시 `ctrl` + `D`
- sys.stdin.buffer.read()
  - 한 번에 모든 입력 받기
  - 입력 종료 시 `ctrl` + `D`
- sys.stdin.readline()

## 8.3. iterable
- zip(iterable)
```python
c = ['ABCDEFG', 'HIJKLMN']
for front, back in zip(*c):
  print(front, back)
---
A X
B Y
C Z
```

## 8.4. itertools
- 순열과 조합을 구할 수 있는 패키지로 [(튜플), (튜플), ...] 형태로 반환
- 순열 : 서로 다른 n개에서 r개를 택하여 일렬로 나열하는 경우의 수
    - nPr = n! / (n-r)!
    - `permutations(iterable, 3)`
- 조합 : 서로 다른 n개에서 순서 생각하지 않고 r개를 택하는 경우의 수
    - nCr = n! / (n-r)!r!
    - `combinations(iterable, 3)`
- 중복 순열 : 중복 가능한 n개에서 r개 나열하는 경우의 수
    - nㅠr = n^r
    - `product(iterable, repeat=3)`
- 중복 조합 : 중복 가능한 n개에서 순서 생각하지 않고 r개 택하는 경우의 수
    - nHr = n+r-1Cr
    - `combinations_with_replacement(iterable, 3)`

## 8.5. GIL (Global Interpreter Lock)
### (1) GIL
- GIL 이란?
  - **Python의 객체들에 대한 접근을 보호하는 일종의 뮤텍스**
  - 여러 개의 쓰레드가 파이썬 코드를 동시에 실행하지 못하도록 하는 것
  - 한 프로세스 내에서 Python 인터프리터는 **한 시점에 하나의 쓰레드에 의해서만 실행** 가능
  - 멀티 쓰레딩 시에도 병렬 실행은 불가능
- GIL의 필요성
  - 공유 자원에 대해 발생할 수 있는 Race Condition 문제 때문에 필요
  - 참조 횟수 기반하여 GC를 진행하는 Python의 특성 상 여러 개의 쓰레드가 Python 인터프리터를 동시에 실행 시 참조 횟수가 올바르게 관리되지 못하는 Race Condition 발생할 수 있음
  - Python에서 GC의 올바른 동작을 보장하려면 모든 객체에 뮤텍스를 걸어줘야 하는데 이는 비효율적이고 실수 유발 가능성이 있기에 GIL을 선택
    - 한 쓰레드가 인터프리터 실행 시 다른 쓰레드들은 Python 인터프리터 실행하지 못하도록 막는 것
    - 한 줄씩 읽어서 실행하는 행위가 동시에 일어나지 못함으로써 객체 참조 횟수에 대한 Race Condition 문제 발생하지 않고 뮤텍스를 일일이 걸을 필요가 없음
- Python에서 멀티 쓰레딩
  - CPU 연산 비중이 큰 경우
    - 병렬 실행도 안되는데 멀티 쓰레딩은 문맥 전환 비용으로 오히려 성능을 떨어트림
  - CPU 연산 비중이 적은 경우
    - 외부 연산(I/O, Sleep, ..) 시에는 다른 쓰레드가 실행되어도 공유 자원의 Race Condition 문제가 발생하지 않음
    - 외부 연산으로 CPU가 기다릴 때는 다른 쓰레드로 문맥 전환 시도하고 멀티 쓰레딩으로 성능 향상 가능
    
### (2) 병렬 처리
- 일반적인 CPU 연산에 대하여 병렬 처리하는 2가지 방법
  - 멀티 프로세싱 이용
    - 한 프로세스의 여러 쓰레드들은 서로 자원을 공유
    - 여러 프로세스들은 각자 독자적인 메모리 공간을 가지고 자원 공유 X
    - 단, 메모리가 더 필요하고, 문맥 전환 비용이 꽤 됨
  - 다른 Python 인터프리터 구현체 사용

### (3) 참고
- Python 인터프리터
  - Python으로 작성된 코드를 한 줄씩 읽으면서 실행하는 프로그램
  - 현재 C언어로 구현한 CPython이 Python 인터프리터의 표준 구현체
- Garbage Collection (GC)
  - Python의 모든 객체는 참조 횟수 저장을 위한 필드를 저장 `sys.getrefcount(객체)`
  - 참조 횟수가 0이 되면 해당 객체를 메모리에서 삭제시키는 메커니즘으로 동작
- Race Condition
  - 하나의 값에 여러 쓰레드가 동시에 접근함으로써 값이 올바르지 않게 읽히거나 쓰일 수 있는 상태 (Thread-safe 하지 않음)
  - 이러한 Race Condition은 Mutex로 예방 가능
- Mutex
  - 멀티 쓰레딩 환경에서 여러 개의 쓰레드가 어떠한 공유 자원에 접근 가능할 때 그 공유 자원에 접근하기 위해 가지고 있어야 하는 일종의 열쇠
  - 한 쓰레드가 특정 공유 자원에 뮤텍스를 가지고 있다면, 다른 쓰레드들은 접근 중인 쓰레드가 뮤텍스를 풀어줄 때까지 기다려야 함