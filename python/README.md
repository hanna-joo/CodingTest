# 1. 파이썬 기초

# 2. 자료구조
## (1) 구간 합 : O(1)
## (2) 투 포인터 : O(nlogn)
## (3) 슬라이딩 윈도우 : O(n)
- 윈도우를 한 칸씩 이동하며 현재 상태 리스트 업데이트
- 슬라이딩 윈도우를 덱으로 구현하면 정렬 효과
  - `deque.append(item)`, `deque.appendleft(item)`, `deque.pop()`, `deque.popleft()`
## (4) 스택과 큐
- 스택(stack)
  - 깊이 우선 탐색(Depth First Search), 백트래킹 종류의 코딩에 효과적
- 큐(queue) 
  - 너비 우선 탐색(Breadth First Search)에서 자주 사용
- 우선순위 큐(priority queue)
  - 기본적으로 정렬 기준은 오름차순 정렬
## (5) 해시

# 3. 완전 탐색

# 4. DFS & BFS
## (1) 깊이 우선 탐색 (Depth-First Search)
- 그래프 완전 탐색 기법 중 하나
- 루트 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식
- 방문하고 스택에 넣어놓고 나중에 넣은 것부터 처리(방문하자마자 처리)
- 후입선출, **스택** 또는 **재귀함수**로 구현
- 구현 요소 : 인접리스트, 방문리스트, 스택/재귀 함수(, 시작 노드)
- 작동 과정
  - (a) 시작 노드 입력 
  - (b-1) 시작 노드 방문 기록 있다면 dfs 종료
  - (b-2) 시작 노드 방문 기록 없다면 방문 기록 후 처리
  - (c) 해당 노드의 인접 노드 하나씩 dfs 수행
## (2) 너비 우선 탐색 (Breadth-First Search)
- 루트 노드에서 시작해서 시작 정점으로부터 인접한 노드를 먼저 탐색하는 방식
- 선입선출, **큐**로 구현
- 방문하고 큐에 넣어놓고 가장 먼저 넣은 것부터 처리
- 구현 요소 : 인접리스트, 방문리스트, 큐(, 탐색 방향, 시작 노드)
- 작동 과정
  - (a) 시작 노드 입력
  - (b) 시작 노드 방문 기록 후 큐에 넣기
  - (c) 큐가 빌 때까지 반복
    - (c-1) 큐에서 가장 앞 노드 추출
    - (c-2) 해당 노드 처리
    - (c-3) 해당 노드의 인접 노드 하나씩 방문 및 큐에 삽입
## (3) DFS vs BFS
- 모든 노드를 방문해야 할 때 DFS, BFS
- 각각의 경로마다 특징을 저장해야 할 때 DFS
- 두 노드 사이의 최단 거리 구해야 할 때 BFS
- 시간 복잡도 = 다음 노드가 방문했는지 시간 + 각 노드 방문 시간
- DFS가 BFS에 비해 구현은 쉽지만 검색 속도는 느림

# 5. 다이나믹 프로그래밍
- 중복된 계산 값을 저장해서 중복 연산을 최소화
## (1) 일반
- 해결 방법
  - (a) 중복되는 계산을 찾고 어떤 값을 저장할 지 정한다
  - (b) 점화식을 세운다
  - (c) 초깃값을 지정한다
## (2) 다익스트라
- 다이나믹 프로그래밍을 활용한 최단 경로 탐색 알고리즘
  - 인공위성 GPS 소프트웨어 등에서 많이 사용
- 하나의 정점에서 **다른 모든 정점으로** 가는 최단 경로(음의 간선X)
- B가 A,C와 연결되어 있을 때
  - (a) B까지의 거리 = A까지의 최단 거리 + A와 B의 최단 거리
  - (b) B까지의 거리 = C까지의 최단 거리 + C와 B의 최단 거리
  - B까지의 최단 거리 = min(a, b)
- 현재까지 알고 있던 최단 경로를 계속 갱신
- 작동 과정
  - (a) 출발 노드 방문 (출발 노드의 거리를 무조건 0으로 하지 말자!)
  - (b) 출발 노드 기준으로 각 노드의 최소 비용 저장
  - (c) **방문하지 않은 노드에서 가장 비용이 적은 노드 방문**
  - (d) 해당 노드 거쳐서 특정 노드로 가는 경우 고려해서 최소 비용 갱신
  - (e) (c)-(d)번 과정 반복

# 6. 그리디 알고리즘
- 해결 방법
  - (a) 해 선택 : 현재 상태에서 가장 최선이라고 생각되는 해를 선택
  - (b) 적절성 검사 : 현재 선택한 해가 전체 문제의 제약 조건에 벗어나지 않는지 검사
  - (c) 해 검사
    - 현재까지 선택한 해 집합이 전체 문제를 해결할 수 있는지 검사
    - 전체 문제를 해결하지 못한다면 1단계로 돌아가 과정 반복
## (2) 대표 예시
- 회의실 예약

# 7. 심화 알고리즘
## (1) 이진 탐색 (Binary Search) : O(logN)
- **데이터가 정렬되어 있는 상태**에서 원하는 값을 찾아내는 알고리즘
- 중앙값 비교를 통한 탐색 범위 절반씩 축소
- 작동 과정
  - (a) 현재 데이터셋의 중앙값(median) 선택
  - (b-1) 중앙값 > 타깃 데이터 : 중앙값 기준으로 왼쪽 데이터셋 선택
  - (b-2) 중앙값 < 타깃 데이터 : 중앙값 기준으로 오른쪽 데이터셋 선택
  - (c) 반복하다가 중앙값 == 타깃 데이터일 때 탐색 종료
- 문제 : doit_29 ~ doit_31

# 8. 기타
## 8.1. 시간 복잡도
- O(1) < O(log(n)) < O(nlog(n)) < O(n^2)
- 자료형에 따른 시간 복잡도
  - List : 삽입, 제거, 탐색, 포함 여부 모두 O(n)
    - 단, append, pop, 인덱스 접근은 O(1)
    - 그 외의 탐색, 확인에는 set, dict 권장
  - Set : 삽입, 제거, 탐색, 포함 여부 O(1)
  - Dict : 삽입, 제거, 탐색, 포함 여부 O(1)
- Python은 1초당 2000만번의 연산 가능
- N에 따른 빅오
  - 500 -> O(N^3)
  - 2,000 -> O(N^2)
  - 100,000 -> O(NlogN)
  - 10,000,000 -> O(N)

## 8.2. 입력
- open(0).read().split()
  - 한 번에 모든 입력 받기
  - 입력 종료 시 `ctrl` + `D`
- sys.stdin.buffer.read()
  - 한 번에 모든 입력 받기
  - 입력 종료 시 `ctrl` + `D`
- sys.stdin.readline()

## 8.3. iterable
- zip(iterable)
```python
c = ['ABCDEFG', 'HIJKLMN']
for front, back in zip(*c):
  print(front, back)
---
A X
B Y
C Z
```

## 8.4. itertools
- 순열과 조합을 구할 수 있는 패키지로 [(튜플), (튜플), ...] 형태로 반환
- 순열 : 서로 다른 n개에서 r개를 택하여 일렬로 나열하는 경우의 수
    - nPr = n! / (n-r)!
    - `permutations(iterable, 3)`
- 조합 : 서로 다른 n개에서 순서 생각하지 않고 r개를 택하는 경우의 수
    - nCr = n! / (n-r)!r!
    - `combinations(iterable, 3)`
- 중복 순열 : 중복 가능한 n개에서 r개 나열하는 경우의 수
    - nㅠr = n^r
    - `product(iterable, repeat=3)`
- 중복 조합 : 중복 가능한 n개에서 순서 생각하지 않고 r개 택하는 경우의 수
    - nHr = n+r-1Cr
    - `combinations_with_replacement(iterable, 3)`

## 8.5. GIL (Global Interpreter Lock)
- 여러 개의 스레드가 파이썬 바이트코드를 한 번에 하나만 사용할 수 있게 락 거는 것
- 하나의 스레드만 파이썬 인터프리터를 제어할 수 있도록 하는 뮤텍스